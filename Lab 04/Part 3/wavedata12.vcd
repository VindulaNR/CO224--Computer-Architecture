$date
	Fri May 15 11:11:51 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_bench $end
$var reg 1 ! CLK $end
$var reg 1 " RESET $end
$scope module mycpu $end
$var wire 1 ! CLK $end
$var wire 1 " RESET $end
$var wire 1 # WRITE $end
$var wire 3 $ WRITE_ADD [2:0] $end
$var wire 1 % SUB_SELECT $end
$var wire 8 & RES1 [7:0] $end
$var wire 8 ' REG_OUT2 [7:0] $end
$var wire 8 ( REG_OUT1 [7:0] $end
$var wire 3 ) OUT2_ADD [2:0] $end
$var wire 3 * OUT1_ADD [2:0] $end
$var wire 8 + OPERAND1 [7:0] $end
$var wire 1 , IMMEDIATAE_SELECT $end
$var wire 8 - IMMEDIATAE [7:0] $end
$var wire 8 . COMPLEMENT [7:0] $end
$var wire 8 / ALU_RESULT [7:0] $end
$var wire 3 0 ALU_OPP [2:0] $end
$scope module my_main_control $end
$var wire 1 ! CLK $end
$var wire 1 " RESET $end
$var wire 1 # WRITE $end
$var wire 3 1 WRITE_ADD [2:0] $end
$var wire 32 2 PC [31:0] $end
$var wire 3 3 OUT2_ADD [2:0] $end
$var wire 3 4 OUT1_ADD [2:0] $end
$var wire 32 5 INSTRUCTION [31:0] $end
$var wire 8 6 IMMEDIATAE [7:0] $end
$var reg 3 7 ALU_OP [2:0] $end
$var reg 1 , IMMEDIATAE_SELECT $end
$var reg 1 % SUB_SELECT $end
$scope module myinstruction_gen $end
$var wire 32 8 INSTRUCTION [31:0] $end
$var wire 7 9 rom_adr [6:0] $end
$var wire 32 : PC [31:0] $end
$upscope $end
$scope module program_counter $end
$var wire 1 ! CLK $end
$var wire 32 ; OUT [31:0] $end
$var wire 1 " RESET $end
$var reg 32 < IN [31:0] $end
$var reg 32 = IN2 [31:0] $end
$upscope $end
$upscope $end
$scope module myalu $end
$var wire 3 > SELECT [0:2] $end
$var wire 8 ? DATA2 [0:7] $end
$var wire 8 @ DATA1 [0:7] $end
$var reg 8 A RESULT [0:7] $end
$upscope $end
$scope module mycomp $end
$var wire 8 B IN [7:0] $end
$var reg 8 C OUT [7:0] $end
$var integer 32 D i [31:0] $end
$upscope $end
$scope module myimmediate $end
$var wire 8 E IN1 [7:0] $end
$var wire 1 , SELECT $end
$var wire 8 F IN0 [7:0] $end
$var reg 8 G OUT [7:0] $end
$upscope $end
$scope module myreg $end
$var wire 1 ! clk $end
$var wire 3 H readAddrA [2:0] $end
$var wire 3 I readAddrB [2:0] $end
$var wire 8 J readDataA [7:0] $end
$var wire 8 K readDataB [7:0] $end
$var wire 1 " reset $end
$var wire 1 # write $end
$var wire 3 L writeAddr [2:0] $end
$var wire 8 M writeData [7:0] $end
$upscope $end
$scope module mysub $end
$var wire 8 N IN0 [7:0] $end
$var wire 8 O IN1 [7:0] $end
$var wire 1 % SELECT $end
$var reg 8 P OUT [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
b0xxxx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
x,
bx +
bx *
bx )
bx (
bx '
bx &
x%
bx $
x#
x"
1!
$end
#1
1#
#3
1"
#5
0!
#6
b0 <
#8
0"
#10
1!
#11
b0 9
b0 2
b0 :
b0 ;
b0 =
#13
b100 <
b1 $
b1 1
b1 L
b111 )
b111 3
b111 I
b0 *
b0 4
b0 H
b10000000011110111 5
b10000000011110111 8
#14
b11110111 +
b11110111 ?
b11110111 G
b11110111 -
b11110111 6
b11110111 E
b0 0
b0 7
b0 >
0%
1,
#15
b0 .
b0 C
b0 O
b1000 D
b0 &
b0 F
b0 P
b11110111 /
b11110111 A
b11110111 M
b0 '
b0 B
b0 K
b0 N
b0 (
b0 @
b0 J
0!
#20
1!
#21
b1 9
b100 2
b100 :
b100 ;
b100 =
#23
b1000 <
b0 $
b0 1
b0 L
b11 )
b11 3
b11 I
b100011 5
b100011 8
#24
b100011 +
b100011 ?
b100011 G
b100011 -
b100011 6
b100011 E
#25
b100011 /
b100011 A
b100011 M
0!
#30
1!
#31
b10 9
b1000 2
b1000 :
b1000 ;
b1000 =
#33
b1100 <
b10 $
b10 1
b10 L
b0 )
b0 3
b0 I
b1 *
b1 4
b1 H
b10000000100000000100000000 5
b10000000100000000100000000 8
#34
b0 +
b0 ?
b0 G
b0 -
b0 6
b0 E
b1 0
b1 7
b1 >
0,
#35
b100011 +
b100011 ?
b100011 G
b11011101 .
b11011101 C
b11011101 O
b1000 D
b100011 &
b100011 F
b100011 P
b100011 '
b100011 B
b100011 K
b100011 N
b11110111 (
b11110111 @
b11110111 J
0!
#36
b11010 /
b11010 A
b11010 M
#40
1!
#41
b11 9
b1100 2
b1100 :
b1100 ;
b1100 =
#43
b10000 <
b11 $
b11 1
b11 L
b1 )
b1 3
b1 I
b10 *
b10 4
b10 H
b11000000110000001000000001 5
b11000000110000001000000001 8
#44
b11011101 +
b11011101 ?
b11011101 G
b11011101 &
b11011101 F
b11011101 P
b1 -
b1 6
b1 E
1%
#45
b1001 +
b1001 ?
b1001 G
b1001 &
b1001 F
b1001 P
b1001 .
b1001 C
b1001 O
b1000 D
b11110111 '
b11110111 B
b11110111 K
b11110111 N
b11010 (
b11010 @
b11010 J
0!
#46
b100011 /
b100011 A
b100011 M
#50
1!
#51
b100 9
b10000 2
b10000 :
b10000 ;
b10000 =
#53
b10100 <
b100 $
b100 1
b100 L
b11 )
b11 3
b11 I
b0 *
b0 4
b0 H
b1000001000000000000000011 5
b1000001000000000000000011 8
#54
b11110111 +
b11110111 ?
b11110111 G
b11110111 &
b11110111 F
b11110111 P
b11 -
b11 6
b11 E
b0 0
b0 7
b0 >
0%
#55
b100011 +
b100011 ?
b100011 G
b11011101 .
b11011101 C
b11011101 O
b1000 D
b100011 &
b100011 F
b100011 P
b11110111 /
b11110111 A
b11110111 M
b100011 '
b100011 B
b100011 K
b100011 N
b100011 (
b100011 @
b100011 J
0!
#56
b100011 /
b100011 A
b100011 M
#60
1!
#61
b101 9
b10100 2
b10100 :
b10100 ;
b10100 =
#63
b11000 <
b101 $
b101 1
b101 L
b100 )
b100 3
b100 I
b1 *
b1 4
b1 H
b100000001010000000100000100 5
b100000001010000000100000100 8
#64
b100 -
b100 6
b100 E
b10 0
b10 7
b10 >
#65
b11110111 (
b11110111 @
b11110111 J
0!
#70
1!
#71
b110 9
b11000 2
b11000 :
b11000 ;
b11000 =
#73
b11100 <
b111 $
b111 1
b111 L
b10 )
b10 3
b10 I
b11 *
b11 4
b11 H
b101000001110000001100000010 5
b101000001110000001100000010 8
#74
b10 -
b10 6
b10 E
b11 0
b11 7
b11 >
#75
b11010 +
b11010 ?
b11010 G
b11100110 .
b11100110 C
b11100110 O
b1000 D
b11010 &
b11010 F
b11010 P
b11010 '
b11010 B
b11010 K
b11010 N
b100011 (
b100011 @
b100011 J
0!
#76
b111011 /
b111011 A
b111011 M
#80
1!
#81
b111 9
b11100 2
b11100 :
b11100 ;
b11100 =
#83
b100000 <
bx $
bx 1
bx L
bx )
bx 3
bx I
bx *
bx 4
bx H
bx 5
bx 8
